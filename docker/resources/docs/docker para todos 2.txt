docker para todos 2

* conectar con un segundo daemon:

docker context ls

(solo aparece el local)

Si queremos ejecutar comandos en otro daemon sin conectar por ssh a ese daemon:

$ DOCKER_HOST="tcp://ip:2375"

En este caso tendremos la API abierta por TCP (menos seguro)

Para conectar teniendolo configurado en local (el daemon externo)

usamos docker context

$ docker context create --docker "host=tcp://ip:2375" pwd
$ docker contetext ls

podemos hacer un switch de context para usar el nuevo daemon:

$ docker context use pwd


podemos configurar conexiones por ssl o hacer un skip de certificados auto-creados

Es posible configurar el archivo de configuración que se ha generado, por si quisieramos modificar directamente algunos parámetros de la conexion del daemon:

$ cd ~/.docker/contexts/meta/{id}
$ vi meta.json

* A partir de la versión 18, podemos conectar con un daemon remoto mediante SSH.

$ docker context create ssh --docker "host=ssh://myremotehost"

Para utilizar "hostaname" en vez de una cadena de conexión propia de ssh (ssh -l usuario host --parametros) deberíamos de crear una configuración ssh en nuestro archivo de configuración ssh local.

Aquí un ejemplo en el que se accede por ssh a "miremotehost" evitando el fingerprint del hostname remoto, y utilizando un certificado .pem en vez de password.

$ cat ~/.ssh/config

Host myremotehost
  StrickHostKeyCheking no
  Hostname 3.210.133.101
  User ubuntu
  IdentityFile ~/.ssh/myremotehost.pem


* Otra característica de la versión 19 es docker app. Es una opción para compartir aplicaciones de forma mas facil, a traves de paquetes tar en git.

Docker app se instala como un plugin en docker 19.83 y en esta versión aún hay que configurar ~/.docker/config.json para que docker trabaje en experimental:

cd; vi .docker/config.json
{
	"experimental": "enabled"
}

$ 

Docker client plugins Manager : lukaszlach/clip

* Mirar también docker buildx


* Mirar también docker cluster

Preguntas frecuentes:

1. Sobre la seguridad en las imágenes Alpile

Es muy segura debida a la cantidad de archivos, binarios, programas, que han sido eliminados. Uno de los lemas es menos paching, mas seguro.

No obstante, es recomendable ir a producción con imágenes basadas en aquellos sistemas operativos qu acostumbremos usar (Debian, Ubuntu, RHEL, CentOS) debido a que Alpine cambia aspectos importantes como el propio gestor de paquetes, ubicación de archivos y binarios, etc... por lo que al final, si no estás acostumbrado a Alpine, tendrás que realizar un gran esfuerzo al principio, e incluso acostumbrarte a este OS, si quieres ir a producción con los menos problemas posibles. EN la mayoría de los casos, este esfuerzo te hará ahorar algunos MB en tu disco, algo que no es especialmente significativo hoy en día.

Un inconveniente de usar Alpine y tal y como se define en (https://kubedex.com/follow-up-scanning-comparison) es el problema que tienen los escaneadores de vulnerabilidades. Alpine, al modificar rutas de archivos o incluso los distributions back-port patches los escaneadores no encuentren vulnerabilidades en sus paquetes.

2. Apache:

Es buena práctica crear un contenedor con Apache + site de forma asislada a ejecutar un contenedor con Apache + multisite. Esto principalmente es por escalabilidad de un site concreto, la actualización del web site (no tener que tirar todos e iniciar todos)... si tuvieramos cientos de sites, igual conviene agruparlos de forma coherente por contenedores, para optimizar recursos en el servidor.

3. Bases de datos en VM's continers o bare


4. Compose vs swarm en un solo servidor: la recomendación es usar siempre swarm en producción aunque solo sea un host debido a que haremos uso de las ventajas de swarm por ejemplo para hacer un rolling upgrade, o actualizaciones, etc... no tendremos downtime, ni tener que re-hacer todo el trabajo. Además siempre estaremos preparados para escalar.


5. Docker environment configuration

	The twelve-Factor APP (12factor.net/config)

	-> Factores a tener en cuenta al desplegar infraestructuras microservicios.

6. ENTRYPOINT vs CMD

El ENTRYPOINT por defecto (si no se ejecuta el comando ENTRYPOINT dentro del Dockerfile, el cual referencia a un ShellScript) es "/bin/sh -c" es decir se prepara para ejecutar un comando a partir de sh, que comando? pues el que hayamos marcado para ejecutar en la entrada CMD del Dockerfile.

Existen varias formas de anular, sobreescribir o utilizar estas dos entradas de Dockerfile

1. No usamos entrypoint pero si un CMD dentro del Dockerfile

* CMD: ["/bin/echo","Hello World!"]

Resultado al inicializar el contenedor:
	El último comando en ejecutarse tras instanciar el contenedor será:

		$ /bin/sh -c "echo Hello World!"

2. Sobreescribimos el CMD:

	$ docker container run --rm image /bin/ls
	bin
	boot
	dev
	etc
	home
	...

3. Utilizar las entradas ENTRYPOINT y CMD en Dockerfile

	FROM ubuntu:16.04
	ENTRYPOINT ["/bin/echo"]
	CMD ["Hello World!"]

El resultado será el mismo que el del punto 1.

4. Sobreescribir el CMD. Este caso es diferente al punto 2 debido a que en el punto 2 no usábamos ningún ENTRYPOINT por lo tanto se ejecutaba el comando 'ls' a través de /bin/sh -c. Ahora el ENTRYPOINT es un /bin/echo y por ello el valor con el que vamos a sustituir al CMD del paso 3, será un argumento para echo.

	$ docker container run --rm image "Esto difiere del punt 2."
	Esto difiere del punt 2.

5. Por último, veremos como sustituir en tiempo de ejecución tanto en ENTRYPOINT como el CMD del Dockerfile. Suponiendo que continuamos con la imagen cosntruida a partir del paso 3. Vamos a modificar el ENTRYPOINT por "/bin/cat" y el CMD por "/etc/release" con lo cual, al instanciar el contenedor, nos imprimirá la versión del OS.

	$ docker container run --rm --entrypoint="/bin/cat" test /etc/lsb-release
	DISTRIB_ID=Ubuntu
	DISTRIB_RELEASE=16.04
	DISTRIB_CODENAME=xenial
	DISTRIB_DESCRIPTION="Ubuntu 16.04.6 LTS"

Ahora que ya hemos visto las sintaxis del comando ENTRYPOINT y CMD dentro de y fuera de un Dockerfile, decir que estábamos utilizando una de las dos formas en las que estos comandos pueden ser instanciados, en este caso usábamos la "exec form" (["valor1","valor2",...]). La otra forma es la utilizada por el comando RUN del Dockerfile y que también es posible para los dos comandos anteriores y es la "shell form" (<instrucción> <comando>). Veamos un ejemplo:

  	FROM ubuntu:16.04
  	RUN apt update && \
  	  apt install wget -y
  	ENV msg "Hello World!"
  	ENTRYPOINT echo "$msg"

 En este ejemplo hemos añadido la definición de una variable y un ENTRYPOINT. Todos los comandos definidos en este Dockerfile están en "Shell form".

 Para terminar, entonces podemos decir que lo definido en el comando ENTRYPOINT se ejecuta siempre antes de lo definido en CMD y que en la mayoría de las veces, se usa CMD para pasar parámetros a un comando que se ejecutará desde dentro de un Shell Script. Este Shell script será ejecutado a su vez por ENTRYPOINT. Un ejemplo es cuando ENTRYPOINT define un shellscript de configuración de un servicio, por ejemplo nginx o mysql y en su último comando, define un comando para inicializar el servicio en si, en CMD podremos entonces ver algunos parámetros que se le pasarán a este servicio.





fshopt -s nullglob

if [ "${1:0:1}" = '-' ]; then

	set -- mysqld "$@"


